# Conclusion

The primary goal of the work was to allow GISpL defined gestures to be recognized in the browser, and to do it in a way to completely support the specification. One additional goal was to adapt the implementation to fit naturally inside of a browser.

Other than some documented exceptions and issues, the primary goal of the work was fulfilled, but this work was for the most part already covered in the original GISpL implementation. What is by that meant is that the actual algorithms behind individual GISpL features were already implemented, although in a different language. On the other hand, the original implementation itself did not cover all parts of the specification, most notably the duration parameter. Additionally, GISpL.js preserved the usage of TUIO as input source despite the presence of browser limitations described in [Managing User Input](#managing-user-input).

As for the other part, GISpL.js first adapts the specification in such a way to work naturally inside of a web page. Second, the implementation was based on an event-based paradigm which is quite common in the JavaScript world. The main idea was then expanded to include user input over TUIO, and the gesture recognition itself, until the final solution was reached. Viewed from the outside, it works in a familiar way to anybody that has worked with a library such as jQuery, and is therefore a flexible solution that is in itself not difficult to use. This makes real world usage realistic and possible.

## Future work

The motivation behind GISpL can be described as the a desire to simplify gesture implementation. This extends to even non-technical people to adjust if not create gesture based interfaces for various devices. In its current form, GISpL.js accomplishes this, but only with TUIO as its input source. Ignoring for the moment the advantages and disadvantages of TUIO, it would also be normal to except a browser based implementation to work with native browser input. One of the future goals of GISpL.js is to therefore work with native browser input, first and foremost with touch input. GISpL.js was already built with this goal in mind, e.g. TUIO objects are not used directly; instead, the input objects are standardized to a common interface. For instance, the current session id of a Tuio.js object can be retrieved by calling the method `getSessionId`, but instead of this, the objects used within GISpL.js contain an `identifier` property that matches the native native touch interface [@touch]. However, the way some native event properties are defined made it less trivial to implement this feature. The biggest issue is that the native touch events register the target of the touch, but the target never changes as long as the input does not change, e.g. finger gets lifted and placed again. While the problem is solvable, the feature did not make it into the final work.

Another useful feature would be to allow the feature set to be extended. As already mentioned in [Validating input as gesture](#validating-input-as-gesture), a GISpL.js gesture object does not care which features it consists of, it cares only if the features report that the input is valid or not. This makes the feature set easily extendible, but only from the inside of the library. Although a user could fork and extend GISpL.js, a better way would maybe be to allow users to add additional features to the library from the outside, similar to the way gestures are added and defined.
